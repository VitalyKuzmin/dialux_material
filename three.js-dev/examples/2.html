<!DOCTYPE html>
<html lang="en">

<head>
	<title>threejs webgl - materials - transmission</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

	<div id="container"></div>
	<div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">threejs</a> - Transmission</div>

	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

	<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

	<script type="module">

		import * as THREE from 'three';

		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';



		const params = {
			color: 0xffffff,
			transmission: 1,
			opacity: 1,
			metalness: 0,
			roughness: 0,
			ior: 1.5,
			thickness: 0.01,
			specularIntensity: 1,
			specularColor: 0xffffff,
			envMapIntensity: 1,
			lightIntensity: 1,
			exposure: 1
		};

		let camera, scene, renderer;

		let mesh, material;

		// const hdrEquirect = new RGBELoader()
		// 	.setPath('textures/equirectangular/')
		// 	.load('royal_esplanade_1k.hdr', function () {

		// 		hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;

		// 		init();
		// 		render();

		// 	});

		let generatedCubeRenderTarget;

		init();
		render();
		// const floorTexture = new textureLoader() //RGBELoader
		// 	.setPath('images/')
		// 	.load('checkerboard.jpg', function () {

		// 		//hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;

		// 		//floorTexture =
		// 		floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
		// 		floorTexture.repeat.set(10, 10);

		// 		init();
		// 		render();

		// 	});

		var SphereCamera;

		function init() {

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			document.body.appendChild(renderer.domElement);

			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = params.exposure;


			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 2000);

			camera.position.set(0, 20, 100);
			//camera.position.set(0, 0, 120);

			//

			//scene.background = hdrEquirect;


			// FLOOR
			const textureLoader = new THREE.TextureLoader();
			var floorTexture = textureLoader.load('images/checkerboard.jpg', () => { render(); }); //new THREE.ImageUtils.loadTexture('images/checkerboard.jpg'); , function () { render(); }
			floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
			floorTexture.repeat.set(10, 10);
			var floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture, side: THREE.DoubleSide }); // floorTexture  map: 'images/checkerboard.jpg',

			var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
			var floor = new THREE.Mesh(floorGeometry, floorMaterial);
			floor.position.y = -100;
			floor.rotation.x = Math.PI / 2;

			floor.position.set(0, -30, 0);
			scene.add(floor);


			// POINT LIGHT
			var light = new THREE.PointLight(0xffffff);
			light.position.set(-100, 150, 100);
			scene.add(light);
			// AMBIENT LIGHT
			var light2 = new THREE.AmbientLight(0x333333);  //333333   //new THREE.Color().setRGB(51, 51, 51)
			light2.position.set(light.position);
			scene.add(light2);





			//var TransMap = new THREE.CubeRefractionMapping(); //SphericalRefractionMapping
			//var ReflMap = new THREE.SphericalReflectionMapping(); //CubeReflectionMapping
			//var Map = 
			//SphereCamera

			//var cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024);
			//SphereCamera = new THREE.CubeCamera(1, 1000, cubeRenderTarget); //0.1, 5000, 512
			// SphereCamera.mapping = THREE.EquirectangularReflectionMapping;
			// SphereCamera.position.set(0, 0, 0);//mesh.position;
			// scene.add(SphereCamera);


			// var cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512);
			// //cubeRenderTarget.texture.type = THREE.HalfFloatType;
			// SphereCamera = new THREE.CubeCamera(1, 1000, cubeRenderTarget);


			//SphereCamera.update(renderer, scene);



			//scene.environment = SphereCamera;

			//CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping

			const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(1024);
			SphereCamera = new THREE.CubeCamera(0.05, 50, cubeRenderTarget);
			// SphereCamera.mapping = THREE.CubeReflectionMapping;
			scene.add(SphereCamera);
			SphereCamera.position.set(0, 0, 0);





			//Sphere

			const geometry = new THREE.SphereGeometry(20, 64, 32);

			material = new THREE.MeshPhysicalMaterial({
				color: params.color,
				metalness: params.metalness,
				roughness: params.roughness,

				ior: params.ior,
				specularIntensity: params.specularIntensity,
				//emissiveIntensity: params.emissiveIntensity,

				transmission: params.transmission, // use material.transmission for glass materials
				thickness: params.thickness,
				attenuationColor: params.attenuationColor,
				attenuationDistance: params.attenuationDistance,


				envMap: cubeRenderTarget.texture,

				//alphaMap: texture,
				//envMap: hdrEquirect,
				//envMap: cubeRenderTarget.texture, //.renderTarget

				opacity: params.opacity,
				specularColor: params.specularColor,
				envMapIntensity: params.envMapIntensity,



				side: THREE.DoubleSide,
				transparent: true
			});

			mesh = new THREE.Mesh(geometry, material);
			mesh.position.set(0, 0, 0);
			scene.add(mesh);






			//

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.addEventListener('change', render); // use if there is no animation loop
			// controls.minDistance = 10;
			// controls.maxDistance = 150;

			// THREE.DefaultLoadingManager.onLoad = function () {

			// 	pmremGenerator.dispose();

			// };


			// const pmremGenerator = new THREE.PMREMGenerator(renderer);
			// pmremGenerator.compileCubemapShader();
			// generatedCubeRenderTarget = pmremGenerator.fromScene(scene);

			// //

			// material.envMap = generatedCubeRenderTarget.texture;

			const gui = new GUI();

			gui.addColor(params, 'color')
				.onChange(function () {

					material.color.set(params.color);
					render();

				});

			gui.add(params, 'transmission', 0, 1, 0.01)
				.onChange(function () {

					material.transmission = params.transmission;
					render();

				});

			gui.add(params, 'opacity', 0, 1, 0.01)
				.onChange(function () {

					material.opacity = params.opacity;
					render();

				});

			gui.add(params, 'metalness', 0, 1, 0.01)
				.onChange(function () {

					material.metalness = params.metalness;
					render();

				});

			gui.add(params, 'roughness', 0, 1, 0.01)
				.onChange(function () {

					material.roughness = params.roughness;
					render();

				});

			gui.add(params, 'ior', 1, 2, 0.01)
				.onChange(function () {

					material.ior = params.ior;
					render();

				});

			gui.add(params, 'thickness', 0, 5, 0.01)
				.onChange(function () {

					material.thickness = params.thickness;
					render();

				});

			gui.add(params, 'specularIntensity', 0, 1, 0.01)
				.onChange(function () {

					material.specularIntensity = params.specularIntensity;
					render();

				});

			gui.addColor(params, 'specularColor')
				.onChange(function () {

					material.specularColor.set(params.specularColor);
					render();

				});

			gui.add(params, 'envMapIntensity', 0, 1, 0.01)
				.name('envMap intensity')
				.onChange(function () {

					material.envMapIntensity = params.envMapIntensity;
					render();

				});

			gui.add(params, 'exposure', 0, 1, 0.01)
				.onChange(function () {

					renderer.toneMappingExposure = params.exposure;
					render();

				});

			gui.open();

		}

		function onWindowResize() {

			const width = window.innerWidth;
			const height = window.innerHeight;

			camera.aspect = width / height;
			camera.updateProjectionMatrix();

			renderer.setSize(width, height);

			render();

		}

		//

		// function generateTexture() {

		// 	const canvas = document.createElement('canvas');
		// 	canvas.width = 2;
		// 	canvas.height = 2;

		// 	const context = canvas.getContext('2d');
		// 	context.fillStyle = 'white';
		// 	context.fillRect(0, 1, 2, 1);

		// 	return canvas;

		// }

		function render() {

			SphereCamera.update(renderer, scene);
			renderer.render(scene, camera);



		}

	</script>
</body>

</html>