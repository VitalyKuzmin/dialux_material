<!doctype html>
<html lang="en">

<head>
	<title>Bubble (Three.js)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css" />
</head>

<body>

	<script src="js/Three.js"></script>
	<script src="js/Detector.js"></script>
	<script src="js/Stats.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/THREEx.KeyboardState.js"></script>
	<script src="js/THREEx.FullScreen.js"></script>
	<script src="js/THREEx.WindowResize.js"></script>

	<!-- GUI for experimenting with values -->
	<script type='text/javascript' src='js/DAT.GUI.min.js'></script>

	<script src="js/shaders/DialuxShader.js"></script>

	<!-- ------------------------------------------------------------ -->

	<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
	<script>
		/*
			Three.js "tutorials by example"
			Author: Lee Stemkoski
			Date: July 2013 (three.js v59dev)
		*/

		// MAIN

		// standard global variables
		var container, scene, camera, renderer, controls, stats;
		var keyboard = new THREEx.KeyboardState();
		var clock = new THREE.Clock();
		// custom global variables
		var cube;

		init();
		animate();

		// FUNCTIONS 		
		function init() {
			// SCENE
			scene = new THREE.Scene();
			// CAMERA
			var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
			var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
			camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
			scene.add(camera);
			camera.position.set(0, 150, 400);
			camera.lookAt(scene.position);
			// RENDERER
			if (Detector.webgl)
				renderer = new THREE.WebGLRenderer({ antialias: true });
			else
				renderer = new THREE.CanvasRenderer();
			renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
			container = document.getElementById('ThreeJS');
			container.appendChild(renderer.domElement);
			// EVENTS
			THREEx.WindowResize(renderer, camera);
			THREEx.FullScreen.bindKey({ charCode: 'm'.charCodeAt(0) });
			// CONTROLS
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			// STATS
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.bottom = '0px';
			stats.domElement.style.zIndex = 100;
			container.appendChild(stats.domElement);
			// LIGHT
			var light = new THREE.PointLight(0xffffff);
			light.position.set(-150, 250, 250);
			scene.add(light);

			// AMBIENT LIGHT
			var light2 = new THREE.AmbientLight(0x333333);  //333333   //new THREE.Color().setRGB(51, 51, 51)
			light2.position.set(light.position);
			scene.add(light2);
			// FLOOR
			var floorTexture = new THREE.ImageUtils.loadTexture('images/checkerboard.jpg');
			floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
			floorTexture.repeat.set(10, 10);
			var floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture, side: THREE.DoubleSide });
			var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
			var floor = new THREE.Mesh(floorGeometry, floorMaterial);
			floor.position.y = -50.5;
			floor.rotation.x = Math.PI / 2;
			scene.add(floor);
			// SKYBOX
			var imagePrefix = "images/dawnmountain-";
			var directions = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
			var imageSuffix = ".png";
			var skyGeometry = new THREE.CubeGeometry(5000, 5000, 5000);

			var urls = [];
			for (var i = 0; i < 6; i++)
				urls.push(imagePrefix + directions[i] + imageSuffix);

			var materialArray = [];
			for (var i = 0; i < 6; i++)
				materialArray.push(new THREE.MeshBasicMaterial({
					map: THREE.ImageUtils.loadTexture(imagePrefix + directions[i] + imageSuffix),
					side: THREE.BackSide
				}));
			var skyMaterial = new THREE.MeshFaceMaterial(materialArray);
			var skyBox = new THREE.Mesh(skyGeometry, skyMaterial);
			scene.add(skyBox);

			////////////
			// CUSTOM //
			////////////



			this.refractSphereCamera = new THREE.CubeCamera(0.1, 5000, 512);
			scene.add(refractSphereCamera);

			var fShader = THREE.FresnelShader;

			// var fresnelUniforms =
			// {
			// 	//"mRefractionRatio": { type: "f", value: 1.02 },
			// 	//"mReflectionFactor": { type: "f", value: 0.5 },
			// 	//"tCube": { type: "t", value: refractSphereCamera.renderTarget },


			// 	// "color": { type: "c", value: new THREE.Color().setRGB(1, 0, 0) },
			// 	//"opacity": { type: "f", value: 1.0 },
			// 	"diffuse": { type: "c", value: new THREE.Color(0xff0000) },
			// 	"ambient": { type: "c", value: new THREE.Color(0x000000) },
			// 	"emissive": { type: "c", value: new THREE.Color(0x000000) },
			// 	"specular": { type: "c", value: new THREE.Color(0x000000) },
			// };

			// create custom material for the shader
			// var customMaterial = new THREE.ShaderMaterial(
			// 	{
			// 		uniforms: fShader.uniforms,// fresnelUniforms,
			// 		vertexShader: fShader.vertexShader,
			// 		fragmentShader: fShader.fragmentShader
			// 	}
			// );

			var customMaterial = new DialuxMaterial({
				color: 0xffffff,
				emissive: 0x000000,
				specular: 0xffffff,
				ambient: 0xffffff,
				shininess: 100,
				reflectivity: 0.5,
				refractionRatio: 1,
				transmission: 0.7,
				envMap: refractSphereCamera.renderTarget,
			})





			//var customMaterial = new THREE.ShaderMaterial();


			// material.uniforms = THREE.UniformsUtils.clone(shaders.uniforms);
			// material.vertexShader = shaders.vertexShader;
			// material.fragmentShader = shaders.fragmentShader;


			//			setMaterialShaders(customMaterial, fresnelUniforms)


			var sphereGeometry = new THREE.SphereGeometry(100, 64, 32);
			this.sphere = new THREE.Mesh(sphereGeometry, customMaterial);
			sphere.position.set(0, 50, 100);
			scene.add(sphere);

			refractSphereCamera.position = sphere.position;



		}

		function animate() {
			requestAnimationFrame(animate);
			render();
			update();
		}

		function update() {
			if (keyboard.pressed("z")) {
				// do something
			}

			controls.update();
			stats.update();
		}

		function render() {
			sphere.visible = false;
			refractSphereCamera.updateCubeMap(renderer, scene);
			sphere.visible = true;

			renderer.render(scene, camera);
		}

	</script>

</body>

</html>